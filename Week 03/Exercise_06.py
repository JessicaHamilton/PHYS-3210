# must import all packages that will be used
import numpy as np
import numpy.random as rand
import matplotlib.pyplot as plt

# Initiall we need to determine the name of the function, tell python that we 
#are making a function and what inputs will be required or optional
def walk(N):
    """ Function to compute an N-step random walk
    
        Input:
            N  ::  Total number of steps

        Output:
            x  ::  Array of all x positions
            y  ::  Array of all y positions

    """
    #Now within the function we need to determine what occurs
    # seed random number generator
    rand.seed()

    # initialize x, y
    #This is where we define and create the arrays for x and y and initiate them
    x = [0.0] 
    y = [0.0]

    # step in x-y space N times
    #This is the for loop that will take each value in the input number given and will perform each task
    #listed within the loop
    for n in range(N):
        #Here we do the calculation where the computer grabs the last value in the x or y array specifically
        #then adds the product of a random value generated by rand.random and subtract 0.5 and multiplied by 2
        #Once computed, it adds this number to the array
        #the loop repeats this process for each value up to the input value twice, once for x and once for y
        x.append(x[-1] + (rand.random() - 0.5)*2.0) #random grabs a random number between 0 and 1
        y.append(y[-1] + (rand.random() - 0.5)*2.0)
    #Once the above for loop is completed, the function will return (give back) the two arrays, x and y
    return np.array(x), np.array(y)


# Example simulation for three separate walkers
walker_1 = walk(1000)   # compute path for 1000 steps
walker_2 = walk(1000)
walker_3 = walk(1000)




# Example plot of (x, y) pairs from example simulation 
plt.plot(walker_1[0], walker_1[1], '-')
plt.plot(walker_2[0], walker_2[1], '-')
plt.plot(walker_3[0], walker_3[1], '-')

plt.title("Three Random Walkers")
plt.xlabel("X Direction")
plt.ylabel("Y Direction")
plt.show()

#With the three random walkers, we can see that the walkers each took different paths
#Even with the fact that each walked took 1000 steps, the random number generator will not generate
#the same numbers for each walker and therefore each path will be different. You can view this by
#looking at the graph, the three different colored lines do not follow each other and are in fact 
#are in different parts of the grid. It do find it interesting that sometimes it seems the walker will remain
#in a specific area. This is not meaning they are in the same spot for an extended time but move around
#that area instead of going in a more straight or "forward" direction.

#Calculate for a single walker how far the walker moved from the origin (not total distance traveled). 
#No, I do not expect each walker to end up at the same distance from the origin. One walker to end up
#moving backwards or in kind of circles.

x_dir = walker_2[0]
y_dir = walker_2[1]
final_x = x_dir[-1]
final_y = y_dir[-1]
dist_origin = np.sqrt(final_x**2+final_y**2)
print("Distance from Origin for walker 2:", dist_origin)



#Run 100 simulations for a walker that takes N steps, calculate final distance input into array
final_distances = []

for each_walker in range(100):
    new_walk = walk(1500)
    x_direction = new_walk[0]
    y_direction = new_walk[1]
    final_x_dir = x_direction[-1]
    final_y_dir = y_direction[-1]
    distance_orig = np.sqrt(final_x_dir**2+final_y_dir**2)
    final_distances.append(distance_orig)
    plt.plot(x_direction, y_direction, '-')
print(final_distances)

#According to the array of final distances, each walker does not end up at the same distance which
# is what I expected. I think this is right. 

#Makes a histogram of the final distances and find average distance, standard deviation, median distance
std_div = np.

hist = histogram(final_distances)
hist.plot()

















